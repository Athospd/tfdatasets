% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataset_iterators.R
\name{batch_from_dataset}
\alias{batch_from_dataset}
\title{Tensor(s) for drawing batches from a dataset}
\usage{
batch_from_dataset(dataset, features = NULL, response = NULL,
  names = c("x", "y"), named_features = FALSE)
}
\arguments{
\item{dataset}{A dataset}

\item{features}{Features to include.}

\item{response}{Response variable (required when \code{features} is specified).}

\item{names}{Names to assign list elements when \code{features} and \code{response} are
specified (defaults to \code{x} and \code{y} for features and response respectively) .}

\item{named_features}{\code{TRUE} to yield features as a named list; \code{FALSE}
to stack features into a single array. Note that in the case of \code{FALSE}
(the default) all features will be stacked into a single 2D tensor
so need to have the same underlying data type.}
}
\value{
Tensor(s) that can be evaluated to yield the next batch of training data.

When \code{features} is specified the tensors will have a structure of either:
\itemize{
\item \code{list(x = list(feature_name = feature_values, ...), y = response_values)} when
\code{named_features} is \code{TRUE}; or
\item \code{list(x = features_array, y = response_values)} when \code{named_features} is \code{FALSE},
where \code{features_array} is a Rank 2 array of \code{(batch_size, num_features)}.
}

Note that by default list elements are named \code{x} and \code{y}. This can be customized
using the \code{names} argument (pass \code{NULL} to return a list with no names).

When \code{features} is not specified the tensors will conform to the
shape and types of the dataset (see \code{\link[=output_shapes]{output_shapes()}} and \code{\link[=output_types]{output_types()}}).
}
\description{
Tensor or list(s) of tensors (e.g. for features and response)
that yield the next batch of data each time they are evaluated.
}
\section{Batch Iteration}{


In many cases you won't need to explicitly iterate over the batches,
rather, you will pass the batch tensors to another function that
evaluates them as part of a training loop (e.g. the Keras
\code{layer_input()} and \code{compile()} functions).

If you do need to iterate explicitly over the batches, you can use
the \code{\link[=for_each_batch]{for_each_batch()}} function. For example:\preformatted{library(tfdatasets)
dataset <- csv_dataset("training.csv") %>%
  dataset_batch(128) %>%
  dataset_repeat(10)
batch <- batch_from_dataset(dataset)
for_each_batch(batch, function(batch) {
  # use batch$x and batch$y tensors
  # (return FALSE to stop iteration early)
})
}
}

\seealso{
\code{\link[=for_each_batch]{for_each_batch()}}; \code{\link[=input_fn_from_dataset]{input_fn_from_dataset()}} for use with \pkg{tfestimators}.
}
