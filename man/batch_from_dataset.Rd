% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataset_iterators.R
\name{batch_from_dataset}
\alias{batch_from_dataset}
\title{Tensor(s) for drawing batches from a dataset}
\usage{
batch_from_dataset(dataset, features = NULL, response = NULL,
  named = TRUE, named_features = FALSE)
}
\arguments{
\item{dataset}{A dataset}

\item{features}{Features to include.}

\item{response}{Response variable.}

\item{named}{\code{TRUE} to assign names to list elements when \code{features} are
specified (defaults to \code{x} and \code{y}, provide a character vector to use
alterate names).}

\item{named_features}{\code{TRUE} to yield features as a named list; \code{FALSE}
to stack features into a single array. Note that in the case of \code{FALSE}
(the default) all features will be stacked into a single 2D tensor
so need to have the same underlying data type.}
}
\value{
Tensor(s) that can be evaluated to yield the next batch of training data.

When \code{features} is specified the tensors will have a structure of either:
\itemize{
\item \code{list(x = list(feature_name = feature_values, ...), y = response_values)} when
\code{named_features} is \code{TRUE}; or
\item \code{list(x = features_array, y = response_values)} when \code{named_features} is \code{FALSE},
where \code{features_array} is a Rank 2 array of \code{(batch_size, num_features)}.
}

Note that by default list elements are named \code{x} and \code{y}. This can be customized
using the \code{named} argument (pass \code{FALSE} to return a list with no names).

When \code{features} is not specified the tensors will conform to the
shape and types of the dataset (see \code{\link[=output_shapes]{output_shapes()}} and \code{\link[=output_types]{output_types()}}).
}
\description{
Tensor or list(s) of tensors (e.g. for features and response)
that yield the next batch of data each time they are evaluated.
}
\section{Batch Iteration}{


In many cases you won't need to explicitly iterate over the batches,
rather, you will pass the tensors to another function that will perform
the evaluation (e.g. the Keras \code{layer_input()} and \code{compile()} functions).

If you do need to perform iteration manually by evaluating the tensors, there
are a couple of possible approaches to controlling/detecting when iteration should
end.

One approach is to create a dataset that yields batches infinitely (traversing
the dataset multiple times with different batches randomly drawn). In this case you'd
use another mechanism like a global step counter or check for a learning plateau.

Another approach is to iteration is to detect when all batches have been yielded
from the dataset. When the batch tensor reaches the end of iteration a runtime
error will occur. You can catch and ignore the error when it occurs by wrapping
your iteration code in the \code{with_dataset_iterator()} function.

See the examples below for a demonstration of each of these methods of iteration.
}

\examples{
\dontrun{

# iteration with 'infinite' dataset and explicit step counter

library(tfdatasets)
dataset <- csv_dataset("training.csv") \%>\%
  dataset_shuffle(5000) \%>\%
  dataset_batch(128) \%>\%
  dataset_repeat()
batch <- batch_from_dataset(dataset, features = c(mpg, disp), response = cyl)
steps <- 200
for (i in 1:steps) {
  # use batch$x and batch$y tensors
}

# iteration that detects and ignores end of iteration error

library(tfdatasets)
dataset <- csv_dataset("training.csv") \%>\%
  dataset_batch(128) \%>\%
  dataset_repeat(10)
batch <- batch_from_dataset(dataset, features = c(mpg, disp), response = cyl)
with_dataset_iterator({
  while(TRUE) {
    # use batch$x and batch$y tensors
  }
})
}

}
\seealso{
\code{\link[=input_fn_from_dataset]{input_fn_from_dataset()}} for use with \pkg{tfestimators}.
}
