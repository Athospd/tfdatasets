% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataset_iterators.R
\name{batches_from_dataset}
\alias{batches_from_dataset}
\title{Draw batches from a dataset}
\usage{
batches_from_dataset(dataset, features = NULL, response = NULL,
  names = c("x", "y"), named_features = FALSE)
}
\arguments{
\item{dataset}{A dataset}

\item{features}{Features to include.}

\item{response}{Response variable (required when \code{features} is specified).}

\item{names}{Names to assign list elements when \code{features} and \code{response} are
specified (defaults to \code{x} and \code{y} for features and response respectively) .}

\item{named_features}{\code{TRUE} to yield features as a named list; \code{FALSE}
to stack features into a single array. Note that in the case of \code{FALSE}
(the default) all features will be stacked into a single 2D tensor
so need to have the same underlying data type.}
}
\value{
Tensor(s) that can be evaluated to yield the next batch of training data.

When \code{features} is specified the tensors will have a structure of either:
\itemize{
\item \code{list(x = list(feature_name = feature_values, ...), y = response_values)} when
\code{named_features} is \code{TRUE}; or
\item \code{list(x = features_array, y = response_values)} when \code{named_features} is \code{FALSE},
where \code{features_array} is a Rank 2 array of \code{(batch_size, num_features)}.
}

Note that by default list elements are named \code{x} and \code{y}. This can be customized
using the \code{names} argument (pass \code{NULL} to return a list with no names).

When \code{features} is not specified the tensors will conform to the
shape and types of the dataset (see \code{\link[=output_shapes]{output_shapes()}} and \code{\link[=output_types]{output_types()}}).
}
\description{
Tensor or list(s) of tensors (e.g. for features and response)
that yield the next batch of data each time they are evaluated.
}
\section{Batch Iteration}{


In many cases you won't need to directly evaluate the batch tensors,
rather, you will pass the tensors to another function that will perform
the evaluation (e.g. the Keras \code{layer_input()} and \code{compile()} functions).

If you do need to perform iteration manually by evaluating the tensors,
a runtime error will occur when the iterator has exhausted all available elements.
You can use the \code{\link[=out_of_range_error]{out_of_range_error()}} function to distinguish this error from other
errors which may have occurred. For example:\preformatted{library(tfdatasets)
dataset <- csv_dataset("training.csv") %>%
  dataset_batch(128) %>%
  dataset_repeat(10)
batch <- batches_from_dataset(dataset)
tryCatch({
  while(TRUE) {
    # use batch$x and batch$y tensors
  }
},
error = function(e) {
  if (!out_of_range_error())
    stop(e)
})
}
}

\seealso{
\code{\link[=input_fn_from_dataset]{input_fn_from_dataset()}} for use with \pkg{tfestimators}.
}
